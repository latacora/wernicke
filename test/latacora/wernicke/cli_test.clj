(ns latacora.wernicke.cli-test
  {:clj-kondo/config {:linters {:private-call {:level :off}}}}
  (:require
   [latacora.wernicke.cli :as cli]
   [clojure.test :as t]
   [clojure.string :as str]
   [cheshire.core :as json]))

(t/deftest verbosity->log-level-tests
  (t/are [n expected] (= (cli/verbosity->log-level n) expected)
    0 :info

    -1 :warn
    -2 :error
    -3 :fatal

    1 :debug
    2 :trace

    ;; extreme cases
    -100 :fatal
    100 :trace))

(defmacro with-fake-exit
  [& body]
  `(with-redefs [cli/exit! (fn [message# code#]
                             (->> {:message message# :code code#}
                                  (ex-info "mock exit! called")
                                  (throw)))]
     (try
       {:exited? false :value ~@body}
       (catch clojure.lang.ExceptionInfo e#
         (if (-> e# .getMessage (= "mock exit! called"))
           {:exited? true :value (ex-data e#)}
           (throw e#)))))) ;; a real bug

(defmacro with-captured-output
  [& body]
  `(let [out# (java.io.StringWriter.)
         err# (java.io.StringWriter.)]
     (binding [*out* out# *err* err#]
       ~@body
       {:out (str out#)
        :err (str err#)})))

(defn cli-test-harness
  [in-str args]
  (with-in-str in-str
    (with-fake-exit
      (with-captured-output
        (apply cli/-main args)))))

(def help-lines
  ["Redact structured data."
   ""
   "Usage: wernicke [OPTIONS] < infile > outfile"
   ""
   "Input is only read from stdin, output only written to stdout."
   ""
   "Options:"
   "  -h, --help                 display help message"
   "  -v, --verbose              increase verbosity"
   "  -p, --pretty               prettify output (if serializer supports it)"
   "  -c, --config EDN           configuration"
   "  -i, --input FORMAT   json  input format (one of json, edn)"
   "  -o, --output FORMAT  json  output format (one of json, edn)"])

(def expected-help
  (str/join \newline help-lines))

(def input
  {:a "2600"}) ;; str not likely to be autogenerated by redaction

(def json
  (json/generate-string input))

(def edn
  (pr-str input))

(defn ^:private pretty-print-test
  [cli-test-harness-args]
  (let [regular (cli-test-harness json cli-test-harness-args)
        pretty (cli-test-harness json (conj cli-test-harness-args "-p"))
        long-pretty (cli-test-harness json (conj cli-test-harness-args "--pretty"))
        count-whitespace (fn [output]
                           (->> output :value :out (filter #{\space \n}) count))]
    (t/is (= false (:exited? regular) (:exited? pretty) (:exited? long-pretty)))
    (t/is (= pretty long-pretty))
    (t/is (not= regular pretty))
    (t/is (< (count-whitespace regular) (count-whitespace pretty)))))

(t/deftest cli-tests
  (t/is (= {:exited? true
            :value {:message expected-help :code 0}}
           (cli-test-harness "{}" ["--help"])))
  (t/is (= {:exited? true
            :value {:message
                    (->> help-lines
                         (into ["The following error occurred while parsing your command:"
                                "Unknown option: \"--nonsense\""
                                ""])
                         (str/join \newline))
                    :code 1}}
           (cli-test-harness "{}" ["--nonsense"])))

  (t/is (= {:exited? false
            :value {:out json
                    :err ""}}
           (cli-test-harness json []))
        "implicit json in, implicit json out")
  (t/is (= {:exited? false
            :value {:out json
                    :err ""}}
           (cli-test-harness json ["--input" "json"]))
        "explicit json in, implicit json out")
  (t/is (= {:exited? false
            :value {:out json
                    :err ""}}
           (cli-test-harness json ["--input=json"]))
        "explicit json in, implicit json out")
  (t/is (= {:exited? false
            :value {:out json
                    :err ""}}
           (cli-test-harness json ["--input" "json" "--output" "json"]))
        "explicit json in, explicit json out")

  (t/is (= {:exited? false
            :value {:out json
                    :err ""}}
           (cli-test-harness edn ["--input" "edn"]))
        "explicit edn in, implicit json out")
  (t/is (= {:exited? false
            :value {:out edn
                    :err ""}}
           (cli-test-harness edn ["--input" "edn" "--output" "edn"]))
        "explicit edn in, explicit edn out")

  (t/testing "pretty printing adds more whitespace"
    (t/testing "json" (pretty-print-test []))
    (t/testing "edn" (pretty-print-test ["--output=edn"])))

  (let [args ["--config"
              (pr-str
               {:extra-rules
                [{:name ::numbers
                  :type :regex
                  ;; note: :pattern can't be a regex literal because while
                  ;; pr-str will produce a string for it, edn/read-string won't
                  ;; be able to consume it again. as a consequence,
                  ;; wc/process-opts has to ensure it's a Pattern.
                  :pattern "\\d*"}]})]
        {:keys [exited? value]} (cli-test-harness json args)]
    (t/is (not exited?))
    (t/is (= "" (:err value)))
    (t/is (not= json (:out value)))))
